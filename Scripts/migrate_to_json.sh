#!/bin/bash

# ==============================================================================
# MIGRACI√ìN DEL SISTEMA LEGACY A JSON v2.0
# Migra el sistema actual de arrays de bash al nuevo sistema JSON
# ==============================================================================

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly OLD_SCRIPT="$SCRIPT_DIR/install-packages.sh"
readonly NEW_JSON="$SCRIPT_DIR/packages.json"
readonly BACKUP_DIR="$SCRIPT_DIR/migration_backup"

info() { echo -e "\033[36m[INFO]\033[0m $*"; }
success() { echo -e "\033[32m[SUCCESS]\033[0m $*"; }
warning() { echo -e "\033[33m[WARNING]\033[0m $*"; }
error() { echo -e "\033[31m[ERROR]\033[0m $*"; }

show_migration_banner() {
    cat << 'EOF'
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üîÑ MIGRACI√ìN A SISTEMA JSON v2.0                  ‚ïë
‚ïë                   Convirtiendo arrays bash ‚Üí JSON                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
}

create_backup() {
    info "üì¶ Creando backup del sistema actual..."
    
    mkdir -p "$BACKUP_DIR"
    
    # Backup de scripts existentes
    if [[ -f "$OLD_SCRIPT" ]]; then
        cp "$OLD_SCRIPT" "$BACKUP_DIR/install-packages_backup_$(date +%Y%m%d_%H%M%S).sh"
    fi
    
    if [[ -f "$NEW_JSON" ]]; then
        cp "$NEW_JSON" "$BACKUP_DIR/packages_backup_$(date +%Y%m%d_%H%M%S).json"
    fi
    
    success "‚úÖ Backup creado en: $BACKUP_DIR"
}

extract_legacy_packages() {
    info "üîç Extrayendo paquetes del script legacy..."
    
    if [[ ! -f "$OLD_SCRIPT" ]]; then
        warning "Script legacy no encontrado: $OLD_SCRIPT"
        return 1
    fi
    
    # Extraer arrays del script bash usando an√°lisis de texto
    local temp_script
    temp_script=$(mktemp)
    
    # Crear un script temporal que solo declare los arrays
    cat > "$temp_script" << 'EOF'
#!/bin/bash

# Declaraci√≥n de arrays para agrupar paquetes por funcionalidad
declare -a installed
declare -a skipped
declare -a user_skipped
declare -a errors
EOF
    
    # Extraer las declaraciones de arrays del script original
    sed -n '/^declare -a/,/^)$/p' "$OLD_SCRIPT" >> "$temp_script"
    
    # Agregar funci√≥n para imprimir arrays en formato JSON
    cat >> "$temp_script" << 'EOF'

# Funci√≥n para convertir arrays a JSON
convert_to_json() {
    echo "{"
    echo '  "legacy_arrays": {'
    
    local arrays=(
        "dotfiles_tools:1. DOTFILES:üîß:Gesti√≥n de dotfiles y control de versiones"
        "system_utilities:2. SYSTEM_UTILITIES:‚öôÔ∏è:Utilidades del sistema y CLI tools"
        "productivity_apps:3. PRODUCTIVITY_APPS:üì±:Aplicaciones de productividad y multimedia"
        "development_tools:4. DEVELOPMENT_TOOLS:üíª:Herramientas de desarrollo y programaci√≥n"
        "terminal_shell:5. TERMINAL_SHELL:üñ•Ô∏è:Terminal y shell"
        "fonts_symbols:6. FONTS_SYMBOLS:üî§:Fuentes y s√≠mbolos"
        "tmux_plugins:7. TMUX_PLUGINS:üì¶:Herramientas y plugins para Tmux"
    )
    
    local first=true
    for array_info in "${arrays[@]}"; do
        IFS=':' read -r array_name category_id emoji description <<< "$array_info"
        
        if [[ "$first" == "true" ]]; then
            first=false
        else
            echo ","
        fi
        
        echo -n "    \"$array_name\": {"
        echo "\"category_id\": \"$category_id\", \"emoji\": \"$emoji\", \"description\": \"$description\", \"packages\": ["
        
        # Obtener referencia al array
        local -n array_ref="$array_name"
        local pkg_first=true
        
        for package in "${array_ref[@]}"; do
            # Limpiar comentarios del nombre del paquete
            local clean_package
            clean_package=$(echo "$package" | sed 's/#.*//' | tr -d ' ')
            
            if [[ -n "$clean_package" ]]; then
                if [[ "$pkg_first" == "true" ]]; then
                    pkg_first=false
                else
                    echo ","
                fi
                echo -n "      \"$clean_package\""
            fi
        done
        
        echo
        echo -n "    ]}"
    done
    
    echo
    echo "  }"
    echo "}"
}

convert_to_json
EOF
    
    # Ejecutar el script temporal para obtener JSON
    chmod +x "$temp_script"
    bash "$temp_script" > "$BACKUP_DIR/legacy_extraction.json"
    rm "$temp_script"
    
    success "‚úÖ Paquetes legacy extra√≠dos a: $BACKUP_DIR/legacy_extraction.json"
}

validate_current_json() {
    info "üîç Validando JSON actual..."
    
    if [[ ! -f "$NEW_JSON" ]]; then
        warning "Archivo packages.json no existe, se crear√° uno nuevo"
        return 1
    fi
    
    if ! jq empty "$NEW_JSON" 2>/dev/null; then
        error "El archivo packages.json actual no es v√°lido"
        return 1
    fi
    
    success "‚úÖ JSON actual es v√°lido"
    return 0
}

create_enhanced_categories() {
    info "üèóÔ∏è  Creando estructura de categor√≠as mejoradas..."
    
    # Verificar si el JSON actual tiene todas las categor√≠as necesarias
    local current_categories
    current_categories=$(jq -r '.categories[].id' "$NEW_JSON" 2>/dev/null || echo "")
    
    local required_categories=(
        "1. DOTFILES"
        "2. CORE_SYSTEM" 
        "3. CLI_TOOLS"
        "4. SYSTEM_MONITORING"
        "5. SECURITY_PRIVACY"
        "6. DESKTOP_TOOLS"
        "7. TERMINAL_SHELL"
        "8. FONTS_SYMBOLS"
        "9. EDITORS_IDES"
        "10. LANGUAGES_RUNTIMES"
        "11. PYTHON_ECOSYSTEM"
        "12. DEV_TOOLS"
        "13. VIRTUALIZATION"
        "14. OFFICE_DOCUMENTS"
        "15. WEB_BROWSERS"
        "16. MUSIC_CLIENTS"
        "17. FILE_SYNC"
        "18. MULTIMEDIA_STREAMING"
        "19. COMMUNICATIONS"
        "20. TERMINAL_MULTIPLEXING"
        "21. CLI_UTILITIES"
        "22. FUN_TOOLS"
    )
    
    local missing_categories=()
    for required in "${required_categories[@]}"; do
        if ! echo "$current_categories" | grep -q "^$required$"; then
            missing_categories+=("$required")
        fi
    done
    
    if [[ ${#missing_categories[@]} -gt 0 ]]; then
        info "üìã Categor√≠as faltantes detectadas: ${missing_categories[*]}"
        info "El JSON actual parece estar completo, no se requiere migraci√≥n adicional"
    else
        success "‚úÖ Todas las categor√≠as requeridas est√°n presentes"
    fi
}

optimize_json_structure() {
    info "‚ö° Optimizando estructura JSON..."
    
    local temp_file
    temp_file=$(mktemp)
    
    # Reformatear y optimizar el JSON
    jq --indent 2 '
    {
      "metadata": {
        "version": "2.0",
        "created": now | todate,
        "description": "Configuraci√≥n de paquetes para dotfiles de Arch Linux",
        "total_categories": (.categories | length),
        "total_packages": ([.categories[].packages[]?] | length)
      },
      "categories": .categories | sort_by(.id)
    }' "$NEW_JSON" > "$temp_file" && mv "$temp_file" "$NEW_JSON"
    
    success "‚úÖ Estructura JSON optimizada"
}

create_migration_scripts() {
    info "üìù Creando scripts de migraci√≥n..."
    
    # Script para hacer permisos ejecutables
    cat > "$SCRIPT_DIR/setup_permissions.sh" << 'EOF'
#!/bin/bash
# Establecer permisos ejecutables para todos los scripts

find "$(dirname "${BASH_SOURCE[0]}")" -name "*.sh" -type f -exec chmod +x {} \;
echo "‚úÖ Permisos ejecutables establecidos para todos los scripts"
EOF
    
    # Script de validaci√≥n post-migraci√≥n
    cat > "$SCRIPT_DIR/validate_migration.sh" << 'EOF'
#!/bin/bash
# Validar que la migraci√≥n fue exitosa

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

echo "üîç Validando migraci√≥n..."

# Verificar archivos principales
files_to_check=(
    "package_installer.sh"
    "json_manager.sh" 
    "packages.json"
)

for file in "${files_to_check[@]}"; do
    if [[ -f "$SCRIPT_DIR/$file" ]]; then
        echo "‚úÖ $file existe"
    else
        echo "‚ùå $file faltante"
        exit 1
    fi
done

# Validar JSON
if ! command -v jq >/dev/null 2>&1; then
    echo "‚ö†Ô∏è  jq no est√° instalado, no se puede validar JSON"
    exit 0
fi

if jq empty "$SCRIPT_DIR/packages.json" 2>/dev/null; then
    echo "‚úÖ packages.json es v√°lido"
else
    echo "‚ùå packages.json inv√°lido"
    exit 1
fi

echo "üéâ Migraci√≥n validada exitosamente"
EOF
    
    chmod +x "$SCRIPT_DIR/setup_permissions.sh"
    chmod +x "$SCRIPT_DIR/validate_migration.sh"
    
    success "‚úÖ Scripts de migraci√≥n creados"
}

show_migration_summary() {
    echo
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë                        üìã RESUMEN DE MIGRACI√ìN                       ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo
    
    local total_categories total_packages
    total_categories=$(jq '.categories | length' "$NEW_JSON" 2>/dev/null || echo "0")
    total_packages=$(jq '[.categories[].packages[]?] | length' "$NEW_JSON" 2>/dev/null || echo "0")
    
    echo "‚úÖ Archivos creados:"
    echo "   üì¶ package_installer.sh - Instalador principal"
    echo "   üîß json_manager.sh - Gestor de JSON"
    echo "   üìÑ packages.json - Base de datos de paquetes"
    echo
    echo "üìä Estad√≠sticas:"
    echo "   üìÅ Total de categor√≠as: $total_categories"
    echo "   üì¶ Total de paquetes: $total_packages"
    echo
    echo "üîÑ Pr√≥ximos pasos:"
    echo "   1. Ejecutar: ./validate_migration.sh"
    echo "   2. Probar: ./json_manager.sh validate"
    echo "   3. Usar: ./package_installer.sh"
    echo
    echo "üíæ Backup disponible en: $BACKUP_DIR"
}

main() {
    show_migration_banner
    
    # Verificar dependencias
    if ! command -v jq >/dev/null 2>&1; then
        error "jq no est√° instalado. Instalando..."
        sudo pacman -S --noconfirm jq
    fi
    
    # Proceso de migraci√≥n
    create_backup
    
    # Si ya tenemos un JSON v√°lido, solo optimizar
    if validate_current_json; then
        optimize_json_structure
        create_migration_scripts
        success "‚úÖ JSON existente optimizado y scripts auxiliares creados"
    else
        warning "JSON no v√°lido o inexistente, usando el sistema actual"
        extract_legacy_packages
        create_enhanced_categories
        create_migration_scripts
    fi
    
    show_migration_summary
    
    success "üéâ ¬°Migraci√≥n completada!"
    echo
    info "Para probar el nuevo sistema, ejecuta:"
    echo "  ./package_installer.sh"
}

# Ejecutar si es llamado directamente
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
